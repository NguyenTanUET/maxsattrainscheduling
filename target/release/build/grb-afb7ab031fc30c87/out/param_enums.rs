use cstr_enum :: * ; # [derive (Debug , Copy , Clone , Eq , PartialEq , Hash , FromCStr , AsCStr)] pub enum DoubleParam { # [doc = "- __Type:__ double (`f64`)\n- __Default:__ Infinity for minimization, -Infinity for maximization\n- __Minimum:__ -Infinity\n- __Maximum:__ Infinity\n\n\nIndicates that you aren't interested in solutions whose objective values are worse than the specified value. If the\nobjective value for the optimal solution is equal to or better than the specified cutoff, the solver will return the\noptimal solution. Otherwise, it will terminate with a CUTOFF status (see the Status Code section for further details).\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/cutoff.html).\n"] Cutoff , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ Infinity\n- __Minimum:__ 0\n- __Maximum:__ Infinity\n\n\nLimits the number of simplex iterations performed. The limit applies to MIP, barrier crossover, and simplex.\nOptimization returns with an ITERATION_LIMIT status if the limit is exceeded (see the Status Code section for further\ndetails).\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/iterationlimit.html).\n"] IterationLimit , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ Infinity\n- __Minimum:__ 0\n- __Maximum:__ Infinity\n\n\nLimits the number of MIP nodes explored. Optimization returns with an NODE_LIMIT status if the limit is exceeded (see\nthe Status Code section for further details). Note that if multiple threads are used for the optimization, the actual\nnumber of explored nodes may be slightly larger than the set limit.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/nodelimit.html).\n"] NodeLimit , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ Infinity\n- __Minimum:__ 0\n- __Maximum:__ Infinity\n\n\nLimits the total time expended (in seconds). Optimization returns with a TIME_LIMIT status if the limit is exceeded (see\nthe Status Code section for further details).\n\nNote that optimization may not stop immediately upon hitting the time limit. It will stop after performing the required\nadditional computations of the attributes associated with the terminated optimization. As a result, the Runtime\nattribute may be larger than the specified `TimeLimit` upon completion, and repeating the optimization with a\n`TimeLimit` set to the Runtime attribute of the stopped optimization may result in additional computations and a larger\nattribute value.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/timelimit.html).\n"] TimeLimit , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ -Infinity\n- __Minimum:__ -Infinity\n- __Maximum:__ Infinity\n\n\nTerminate as soon as the engine finds a feasible solution whose objective value is at least as good as the specified\nvalue. Optimization returns with an USER_OBJ_LIMIT status in this case.\n\nNote that you should always include a small tolerance in this value. Without this, a solution that satisfies the\nintended termination criterion may not actually lead to termination due to numerical round-off in the objective.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/bestobjstop.html).\n"] BestObjStop , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ Infinity\n- __Minimum:__ -Infinity\n- __Maximum:__ Infinity\n\n\nTerminates as soon as the engine determines that the best bound on the objective value is at least as good as the\nspecified value. Optimization returns with an USER_OBJ_LIMIT status in this case.\n\nNote that you should always include a small tolerance in this value. Without this, a bound that satisfies the intended\ntermination criterion may not actually lead to termination due to numerical round-off in the bound.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/bestbdstop.html).\n"] BestBdStop , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 1e-6\n- __Minimum:__ 1e-9\n- __Maximum:__ 1e-2\n\n\nAll constraints must be satisfied to a tolerance of FeasibilityTol. Tightening this tolerance can produce smaller\nconstraint violations, but for numerically challenging models it can sometimes lead to much larger iteration counts.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/feasibilitytol.html).\n"] FeasibilityTol , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 1e-5\n- __Minimum:__ 1e-9\n- __Maximum:__ 1e-1\n\n\nAn integrality restriction on a variable is considered satisfied when the variable's value is less than `IntFeasTol`\nfrom the nearest integer value. Tightening this tolerance can produce smaller integrality violations, but very tight\ntolerances may significantly increase runtime. Loosening this tolerance rarely reduces runtime.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/intfeastol.html).\n"] IntFeasTol , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 0.0078125\n- __Minimum:__ 1e-4\n- __Maximum:__ 0.999\n\n\nThe Markowitz tolerance is used to limit numerical error in the simplex algorithm. Specifically, larger values reduce\nthe error introduced in the simplex basis factorization. A larger value may avoid numerical problems in rare situations,\nbut it will also harm performance.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/markowitztol.html).\n"] MarkowitzTol , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 1e-4\n- __Minimum:__ 0\n- __Maximum:__ Infinity\n\n\nThe MIP solver will terminate (with an optimal result) when the gap between the lower and upper objective bound is less\nthan `MIPGap` times the absolute value of the incumbent objective value. More precisely, if $z_P$ is the primal\nobjective bound (i.e., the incumbent objective value, which is the upper bound for minimization problems), and $z_D$ is\nthe dual objective bound (i.e., the lower bound for minimization problems), then the MIP gap is defined as\n\n$gap = \\vert z_P - z_D\\vert / \\vert z_P\\vert$.\n\nNote that if $z_P = z_D = 0$, then the gap is defined to be zero. If $z_P = 0$ and $z_D \\neq 0$, the gap is defined to\nbe infinity.\n\nFor most models, $z_P$ and $z_D$ will have the same sign throughout the optimization process, and then the gap is\nmonotonically decreasing. But if $z_P$ and $z_D$ have opposite signs, the relative gap may increase after finding a new\nincumbent solution, even though the absolute gap $\\vert z_P - z_D\\vert$ has decreased.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/mipgap2.html).\n"] MIPGap , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 1e-10\n- __Minimum:__ 0\n- __Maximum:__ Infinity\n\n\nThe MIP solver will terminate (with an optimal result) when the gap between the lower and upper objective bound is less\nthan MIPGapAbs.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/mipgapabs.html).\n"] MIPGapAbs , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 1e-6\n- __Minimum:__ 1e-9\n- __Maximum:__ 1e-2\n\n\nReduced costs must all be smaller than `OptimalityTol` in the improving direction in order for a model to be declared\noptimal.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/optimalitytol.html).\n"] OptimalityTol , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 1e-6\n- __Minimum:__ 0\n- __Maximum:__ Infinity\n\n\nSets a limit on the amount of diagonal perturbation that the optimizer is allowed to perform on a Q matrix in order to\ncorrect minor PSD violations. If a larger perturbation is required, the optimizer will terminate with a\nGRB_ERROR_Q_NOT_PSD error.\n\nNote: Only affects QP/QCP/MIQP/MIQCP models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/psdtol.html).\n"] PSDTol , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 0.0002\n- __Minimum:__ 0\n- __Maximum:__ Infinity\n\n\nMagnitude of the simplex perturbation. Note that perturbation is only applied when progress has stalled, so the\nparameter will often have no effect.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/perturbvalue.html).\n"] PerturbValue , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 0.0\n- __Minimum:__ -1\n- __Maximum:__ Infinity\n\n\nWhen positive, divides the model objective by the specified value to avoid numerical issues that may result from very\nlarge or very small objective coefficients. The default value of 0 decides on the scaling automatically. A value less\nthan zero uses the maximum coefficient to the specified power as the scaling (so ObjScale=-0.5 would scale by the square\nroot of the largest objective coefficient).\n\nNote that objective scaling can lead to large dual violations on the original, unscaled objective when the optimality\ntolerance with the scaled objective is barely satisfied, so it should be used sparingly. Note also that scaling will be\nmore effective when all objective coefficients are of similar orders of magnitude, as opposed to objectives with a wide\nrange of coefficients. In the latter case, consider using the Multiple Objectives feature instead.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/objscale.html).\n"] ObjScale , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 1e-8\n- __Minimum:__ 0.0\n- __Maximum:__ 1.0\n\n\nThe barrier solver terminates when the relative difference between the primal and dual objective values is less than the\nspecified tolerance (with a GRB_OPTIMAL status). Tightening this tolerance often produces a more accurate solution,\nwhich can sometimes reduce the time spent in crossover. Loosening it causes the barrier algorithm to terminate with a\nless accurate solution, which can be useful when barrier is making very slow progress in later iterations.\n\nNote: Barrier only\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/barconvtol.html).\n"] BarConvTol , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 1e-6\n- __Minimum:__ 0.0\n- __Maximum:__ 1.0\n\n\nWhen solving a QCP model, the barrier solver terminates when the relative difference between the primal and dual\nobjective values is less than the specified tolerance (with a GRB_OPTIMAL status). Tightening this tolerance may lead to\na more accurate solution, but it may also lead to a failure to converge.\n\nNote: Barrier only\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/barqcpconvtol.html).\n"] BarQCPConvTol , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 0.05\n- __Minimum:__ 0\n- __Maximum:__ 1\n\n\nDetermines the amount of time spent in MIP heuristics. You can think of the value as the desired fraction of total MIP\nruntime devoted to heuristics (so by default, we aim to spend 5% of runtime on heuristics). Larger values produce more\nand better feasible solutions, at a cost of slower progress in the best bound.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/heuristics.html).\n"] Heuristics , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 0.0\n- __Minimum:__ 0.0\n- __Maximum:__ Infinity\n\n\nThe MIP solver can change parameter settings in the middle of the search in order to adopt a strategy that gives up on\nmoving the best bound and instead devotes all of its effort towards finding better feasible solutions. This parameter\nallows you to specify an optimality gap at which the MIP solver switches to a solution improvement strategy. For\nexample, setting this parameter to 0.1 will cause the MIP solver to switch strategies once the relative optimality gap\nis smaller than 0.1.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/improvestartgap.html).\n"] ImproveStartGap , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ Infinity\n- __Minimum:__ 0.0\n- __Maximum:__ Infinity\n\n\nThe MIP solver can change parameter settings in the middle of the search in order to adopt a strategy that gives up on\nmoving the best bound and instead devotes all of its effort towards finding better feasible solutions. This parameter\nallows you to specify the time when the MIP solver switches to a solution improvement strategy. For example, setting\nthis parameter to 10 will cause the MIP solver to switch strategies 10 seconds after starting the optimization.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/improvestarttime.html).\n"] ImproveStartTime , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ Infinity\n- __Minimum:__ 0.0\n- __Maximum:__ Infinity\n\n\nThe MIP solver can change parameter settings in the middle of the search in order to adopt a strategy that gives up on\nmoving the best bound and instead devotes all of its effort towards finding better feasible solutions. This parameter\nallows you to specify the node count at which the MIP solver switches to a solution improvement strategy. For example,\nsetting this parameter to 10 will cause the MIP solver to switch strategies once the node count is larger than 10.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/improvestartnodes.html).\n"] ImproveStartNodes , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ Infinity\n- __Minimum:__ 0\n- __Maximum:__ Infinity\n\n\nIf you find that the Gurobi optimizer exhausts memory when solving a MIP, you should modify the `NodefileStart`\nparameter. When the amount of memory used to store nodes (measured in GB, i.e., $10^9$ bytes) exceeds the specified\nparameter value, nodes are compressed and written to disk. We recommend a setting of 0.5, but you may wish to choose a\ndifferent value, depending on the memory available in your machine. By default, nodes are written to the current working\ndirectory. The `NodefileDir` parameter can be used to choose a different location.\n\nIf you still exhaust memory after setting the `NodefileStart` parameter to a small value, you should try limiting the\nthread count. Each thread in parallel MIP requires a copy of the model, as well as several other large data structures.\nReducing the `Threads` parameter can sometimes significantly reduce memory usage.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/nodefilestart.html).\n"] NodefileStart , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ Infinity\n\n\nLimits the amount of time (in seconds) spent in the NoRel heuristic. This heuristic searches for high-quality feasible\nsolutions before solving the root relaxation. It can be quite useful on models where the root relaxation is particularly\nexpensive.\n\nNote that this parameter will introduce non-determinism - different runs may take different paths. Use the\n`NoRelHeurWork` parameter for deterministic results.\n\nNote: Only affects MIP models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/norelheurtime.html).\n"] NoRelHeurTime , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ Infinity\n\n\nLimits the amount of work spent in the NoRel heuristic. This heuristic searches for high-quality feasible solutions\nbefore solving the root relaxation. It can be quite useful on models where the root relaxation is particularly\nexpensive.\n\nThe work metric used in this parameter is tough to define precisely. A single unit corresponds to roughly a second, but\nthis will depend on the machine, the core count, and in some cases the model. You may need to experiment to find a good\nsetting for your model.\n\nNote: Only affects MIP models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/norelheurwork.html).\n"] NoRelHeurWork , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ Infinity\n\n\nThis parameter allows you to set a limit (in seconds) on how long a new Compute Server job will wait in queue before it\ngives up (and reports a JOB_REJECTED error). Note that there might be a delay of up to 20 seconds for the actual\nsignaling of the time out.\n\nAny negative value will allow a job to sit in the Compute Server queue indefinitely.\n\nYou must set this parameter through a gurobi.lic file (using QUEUETIMEOUT=n) or an empty environment. Changing the\nparameter after your environment has been created will have no effect.\n\nRefer to the Gurobi Remote Services Reference Manual for more information on starting Compute Server jobs.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/csqueuetimeout.html).\n"] CSQueueTimeout , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 1e6\n- __Minimum:__ 0\n- __Maximum:__ Infinity\n\n\nWhen relaxing a constraint in a feasibility relaxation, it is sometimes necessary to introduce a big-M value. This\nparameter determines the default magnitude of that value.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/feasrelaxbigm.html).\n"] FeasRelaxBigM , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 1e10\n\n\nControls the automatic reformulation of SOS1 constraints into binary form. SOS1 constraints are often handled more\nefficiently using a binary representation. The reformulation often requires big-M values to be introduced as\ncoefficients. This parameter specifies the largest big-M that can be introduced by presolve when performing this\nreformulation. Larger values increase the chances that an SOS1 constraint will be reformulated, but very large values\n(e.g., 1e8) can lead to numerical issues.\n\nThe default value of -1 chooses a threshold automatically. You should set the parameter to 0 to shut off SOS1\nreformulation entirely, or a large value to force reformulation.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/presos1bigm.html).\n"] PreSOS1BigM , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 1e10\n\n\nControls the automatic reformulation of SOS2 constraints into binary form. SOS2 constraints are often handled more\nefficiently using a binary representation. The reformulation often requires big-M values to be introduced as\ncoefficients. This parameter specifies the largest big-M that can be introduced by presolve when performing this\nreformulation. Larger values increase the chances that an SOS2 constraint will be reformulated, but very large values\n(e.g., 1e8) can lead to numerical issues.\n\nThe default value of -1 chooses a threshold automatically. You should set the parameter to 0 to shut off SOS2\nreformulation entirely, or a large value to force reformulation.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/presos2bigm.html).\n"] PreSOS2BigM , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ Infinity\n\n\nLimits total tuning runtime (in seconds). The default setting (-1) chooses a time limit automatically.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/tunetimelimit.html).\n"] TuneTimeLimit , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 0.0\n- __Minimum:__ 0.0\n- __Maximum:__ 1.0\n\n\nEnables a cleanup phase at the end of tuning. The parameter indicates the percentage of total tuning time to devote to\nthis phase, with a goal of reducing the number of parameter changes required to achieve the best tuning result.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/tunecleanup.html).\n"] TuneCleanup , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ Infinity\n- __Minimum:__ 0\n- __Maximum:__ Infinity\n\n\nDetermines how large a (relative) gap to tolerate in stored solutions. When this parameter is set to a non-default\nvalue, solutions whose objective values exceed that of the best known solution by more than the specified (relative) gap\nare discarded. For example, if the MIP solver has found a solution at objective 100, then a setting of PoolGap=0.2 would\ndiscard solutions with objective worse than 120 (assuming a minimization objective).\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/poolgap.html).\n"] PoolGap , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ Infinity\n- __Minimum:__ 0\n- __Maximum:__ Infinity\n\n\nDetermines how large a (absolute) gap to tolerate in stored solutions. When this parameter is set to a non-default\nvalue, solutions whose objective values exceed that of the best known solution by more than the specified (absolute) gap\nare discarded. For example, if the MIP solver has found a solution at objective 100, then a setting of PoolGapAbs=20\nwould discard solutions with objective worse than 120 (assuming a minimization objective).\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/poolgapabs.html).\n"] PoolGapAbs , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 1e-2\n- __Minimum:__ 1e-5\n- __Maximum:__ 1e+6\n\n\nIf the `FuncPieces` parameter is set to value $1$, this parameter gives the length of each piece of the piecewise-linear\napproximation.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/funcpiecelength2.html).\n"] FuncPieceLength , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 1e-3\n- __Minimum:__ 1e-6\n- __Maximum:__ 1e+6\n\n\nIf the `FuncPieces` parameter is set to value $-1$ or $-2$, this attribute provides the maximum allowed error (absolute\nfor $-1$, relative for $-2$) in the piecewise-linear approximation.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/funcpieceerror2.html).\n"] FuncPieceError , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 1\n\n\nThis parameter controls whether the piecewise-linear approximation of a function constraint is an underestimate of the\nfunction, an overestimate, or somewhere in between. A value of $0.0$ will always underestimate, while a value of $1.0$\nwill always overestimate. A value in between will interpolate between the underestimate and the overestimate. A special\nvalue of -1 chooses points that are on the original function.\n\nSee the discussion of function constraints for more information.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/funcpieceratio2.html).\n"] FuncPieceRatio , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 1e+6\n- __Minimum:__ 0\n- __Maximum:__ Infinity\n\n\nVery large values in piecewise-linear approximations can cause numerical issues. This parameter limits the bounds on the\nvariables that participate in function constraints. Specifically, if $x$ or $y$ participate in a function constraint,\nany bound larger than `FuncMaxVal` (in absolute value) will be truncated.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/funcmaxval.html).\n"] FuncMaxVal , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ Infinity\n- __Minimum:__ 0\n- __Maximum:__ Infinity\n\n\nLimits the total amount of memory (in GB, i.e., $10^9$ bytes) available to Gurobi. If more is needed, Gurobi will fail\nwith an OUT_OF_MEMORY error (see the Error Code section for further details).\n\nThis parameter must be set when the Gurobi environment is first created. You will need to create an empty environment,\nset the parameter, and then start the environment.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/memlimit.html).\n"] MemLimit , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ Infinity\n\n\nA target gap to be reached. As soon as the tuner has found parameter settings that allow Gurobi to reach the target gap\nfor the given model(s), it stops trying to improve parameter settings further. Instead, the tuner switches into the\ncleanup phase (see `TuneCleanup` parameter).\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/tunetargetmipgap.html).\n"] TuneTargetMIPGap , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ 0.005\n- __Minimum:__ 0\n- __Maximum:__ Infinity\n\n\nA target runtime in seconds to be reached. As soon as the tuner has found parameter settings that allow Gurobi to solve\nthe model(s) within the target runtime, it stops trying to improve parameter settings further. Instead, the tuner\nswitches into the cleanup phase (see `TuneCleanup` parameter).\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/tunetargettime.html).\n"] TuneTargetTime , # [doc = "- __Type:__ double (`f64`)\n- __Default:__ Infinity\n- __Minimum:__ 0\n- __Maximum:__ Infinity\n\n\nLimits the total work expended (in work units). Optimization returns with a WORK_LIMIT status if the limit is exceeded\n(see the Status Code section for further details).\n\nIn contrast to the TimeLimit, work limits are deterministic. This means that on the same hardware and with the same\nparameter and attribute settings, a work limit will stop the optimization of a given model at the exact same point every\ntime. One work unit corresponds very roughly to one second on a single thread, but this greatly depends on the hardware\non which Gurobi is running and the model that is being solved.\n\nNote that optimization may not stop immediately upon hitting the work limit. It will stop when the optimization is next\nin a deterministic state, and it will then perform the required additional computations of the attributes associated\nwith the terminated optimization. As a result, the Work attribute may be larger than the specified `WorkLimit` upon\ncompletion, and repeating the optimization with a `WorkLimit` set to the Work attribute of the stopped optimization may\nresult in additional computations and a larger attribute value.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/worklimit.html).\n"] WorkLimit } # [derive (Debug , Copy , Clone , Eq , PartialEq , Hash , FromCStr , AsCStr)] pub enum IntParam { # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 1000\n- __Minimum:__ 0\n- __Maximum:__ MAXINT\n\n\nLimits the number of barrier iterations performed. This parameter is rarely used. If you would like barrier to terminate\nearly, it is almost always better to use the `BarConvTol` parameter instead.\n\nOptimization returns with an ITERATION_LIMIT status if the limit is exceeded (see the Status Code section for further\ndetails).\n\nNote: Barrier only\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/bariterlimit.html).\n"] BarIterLimit , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ MAXINT\n- __Minimum:__ 1\n- __Maximum:__ MAXINT\n\n\nLimits the number of feasible MIP solutions found. Optimization returns with a SOLUTION_LIMIT status once the limit has\nbeen reached (see the Status Code section for further details).\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/solutionlimit.html).\n"] SolutionLimit , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 5\n\n\nAlgorithm used to solve continuous models or the initial root relaxation of a MIP model. Options are: -1=automatic,\n0=primal simplex, 1=dual simplex, 2=barrier, 3=concurrent, 4=deterministic concurrent, 5=deterministic concurrent\nsimplex.\n\nIn the current release, the default Automatic (-1) setting will typically choose non-deterministic concurrent (Method=3)\nfor an LP, barrier (Method=2) for a QP or QCP, and dual (Method=1) for the MIP root relaxation. Only the simplex and\nbarrier algorithms are available for continuous QP models. Only primal and dual simplex are available for solving the\nroot of an MIQP model. Only barrier is available for continuous QCP models.\n\nConcurrent optimizers run multiple solvers on multiple threads simultaneously, and choose the one that finishes first.\nMethod=3 and Method=4 will run dual simplex, barrier, and sometimes primal simplex (depending on the number of available\nthreads). Method=5 will run both primal and dual simplex. The deterministic options (Method=4 and Method=5) give the\nexact same result each time, while Method=3 is often faster but can produce different optimal bases when run multiple\ntimes.\n\nThe default setting is rarely significantly slower than the best possible setting, so you generally won't see a big gain\nfrom changing this parameter. There are classes of models where one particular algorithm is consistently fastest,\nthough, so you may want to experiment with different options when confronted with a particularly difficult model.\n\nNote that if memory is tight on an LP model, you should consider using the dual simplex method (Method=1). The\nconcurrent optimizer, which is typically chosen when using the default setting, consumes a lot more memory than dual\nsimplex alone.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/method.html).\n"] Method , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 3\n\n\nControls model scaling. By default, the rows and columns of the model are scaled in order to improve the numerical\nproperties of the constraint matrix. The scaling is removed before the final solution is returned. Scaling typically\nreduces solution times, but it may lead to larger constraint violations in the original, unscaled model. Turning off\nscaling (ScaleFlag=0) can sometimes produce smaller constraint violations. Choosing a different scaling option can\nsometimes improve performance for particularly numerically difficult models.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/scaleflag.html).\n"] ScaleFlag , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 3\n\n\nDetermines the simplex variable pricing strategy. Available options are Automatic (-1), Partial Pricing (0), Steepest\nEdge (1), Devex (2), and Quick-Start Steepest Edge (3).\n\nChanging the value of this parameter rarely produces a significant benefit.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/simplexpricing.html).\n"] SimplexPricing , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 1\n\n\nEnables or disables quad precision computation in simplex. The -1 default setting allows the algorithm to decide. `Quad`\nprecision can sometimes help solve numerically challenging models, but it can also significantly increase runtime.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/quad.html).\n"] Quad , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 3\n\n\nChooses from among multiple pricing norm variants. The details of how this parameter affects the simplex pricing\nalgorithm are subtle and difficult to describe, so we've simply labeled the options 0 through 3. The default value of -1\nchooses automatically.\n\nChanging the value of this parameter rarely produces a significant benefit.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/normadjust.html).\n"] NormAdjust , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nEnables or disables sifting within dual simplex. `Sifting` can be useful for LP models where the number of variables is\nmany times larger than the number of constraints (we typically only see significant benefits when the ratio is 100 or\nmore). Options are Automatic (-1), Off (0), Moderate (1), and Aggressive (2). With a Moderate setting, sifting will be\napplied to LP models and to the initial root relaxation for MIP models. With an Aggressive setting, sifting will be\napplied any time dual simplex is used, including at the nodes of a MIP. Note that this parameter has no effect if you\naren't using dual simplex. Note also that Gurobi will ignore this parameter in cases where sifting is obviously a worse\nchoice than dual simplex.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/sifting.html).\n"] Sifting , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nLP method used to solve sifting sub-problems. Options are Automatic (-1), Primal Simplex (0), Dual Simplex (1), and\nBarrier (2). Note that this parameter only has an effect when you are using dual simplex and sifting has been selected\n(either automatically by dual simplex, or through the `Sifting` parameter).\n\nChanging the value of this parameter rarely produces a significant benefit.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/siftmethod.html).\n"] SiftMethod , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ MAXINT\n\n\nLimits the number of central corrections performed in each barrier iteration. The default value chooses automatically,\ndepending on problem characteristics. The automatic strategy generally works well, although it is often possible to\nobtain higher performance on a specific model by selecting a value manually.\n\nNote: Barrier only\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/barcorrectors.html).\n"] BarCorrectors , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 1\n\n\nDetermines whether to use the homogeneous barrier algorithm. At the default setting (-1), it is only used when barrier\nsolves a node relaxation for a MIP model. Setting the parameter to 0 turns it off, and setting it to 1 forces it on. The\nhomogeneous algorithm is useful for recognizing infeasibility or unboundedness. It is a bit slower than the default\nalgorithm.\n\nNote: Barrier only\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/barhomogeneous.html).\n"] BarHomogeneous , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 1\n\n\nChooses the barrier sparse matrix fill-reducing algorithm. A value of 0 chooses Approximate Minimum Degree ordering,\nwhile a value of 1 chooses Nested Dissection ordering. The default value of -1 chooses automatically. You should only\nmodify this parameter if you notice that the barrier ordering phase is consuming a significant fraction of the overall\nbarrier runtime.\n\nNote: Barrier only\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/barorder.html).\n"] BarOrder , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 4\n\n\nDetermines the crossover strategy used to transform the interior solution produced by barrier into a basic solution\n(note that crossover is not available for QP or QCP models). `Crossover` consists of three phases: (i) a primal push\nphase, where primal variables are pushed to bounds, (ii) a dual push phase, where dual variables are pushed to bounds,\nand (iii) a cleanup phase, where simplex is used to remove any primal or dual infeasibilities that remain after the push\nphases are complete. The order of the first two phases and the algorithm used for the third phase are both controlled by\nthe `Crossover` parameter:\n\nParameter value First push Second push Cleanup\n\n0 Disabled Disabled Disabled\n\n1 Dual Primal Primal\n\n2 Dual Primal Dual\n\n3 Primal Dual Primal\n\n4 Primal Dual Dual\n\nThe default value of -1 chooses the strategy automatically. Use value 0 to disable crossover; this setting returns the\ninterior solution computed by barrier.\n\nNote: Barrier only\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/crossover.html).\n"] Crossover , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ 1\n\n\nDetermines the initial basis construction strategy for crossover. The default value (0) chooses an initial basis\nquickly. A value of 1 can take much longer, but often produces a more numerically stable start basis.\n\nNote: Barrier only\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/crossoverbasis.html).\n"] CrossoverBasis , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ -1\n- __Maximum:__ 1\n\n\nDetermines which child node is explored first in the branch-and-cut search. The default value chooses automatically. A\nvalue of -1 will always explore the down branch first, while a value of 1 will always explore the up branch first.\n\nChanging the value of this parameter rarely produces a significant benefit.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/branchdir.html).\n"] BranchDir , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ MAXINT\n\n\nLimits degenerate simplex moves. These moves are performed to improve the integrality of the current relaxation\nsolution. By default, the algorithm chooses the number of degenerate move passes to perform automatically.\n\nThe default setting generally works well, but there can be cases where an excessive amount of time is spent after the\ninitial root relaxation has been solved but before the cut generation process or the root heuristics have started. If\nyou see multiple 'Total elapsed time' messages in the log immediately after the root relaxation log, you may want to try\nsetting this parameter to 0.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/degenmoves.html).\n"] DegenMoves , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nA MIP model can sometimes be made up of multiple, completely independent sub-models. This parameter controls how\naggressively we try to exploit this structure. A value of 0 ignores this structure entirely, while larger values try\nmore aggressive approaches. The default value of -1 chooses automatically.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/disconnected.html).\n"] Disconnected , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ 1\n\n\nOne unfortunate reality in MIP is that integer variables don't always take exact integral values. While this typically\ndoesn't create significant problems, in some situations the side-effects can be quite undesirable. The best-known\nexample is probably a trickle flow, where a continuous variable that is meant to be zero when an associated binary\nvariable is zero instead takes a non-trivial value. More precisely, given a constraint $y \\leq M b$, where $y$ is a non-\nnegative continuous variable, $b$ is a binary variable, and $M$ is a constant that captures the largest possible value\nof $y$, the constraint is intended to enforce the relationship that $y$ must be zero if $b$ is zero. With the default\ninteger feasibility tolerance, the binary variable is allowed to take a value as large as $1e-5$ while still being\nconsidered as taking value zero. If the $M$ value is large, then the $M b$ upper bound on the $y$ variable can be\nsubstantial.\n\nReducing the value of the `IntFeasTol` parameter can mitigate the effects of such trickle flows, but often at a\nsignificant cost, and often with limited success. The `IntegralityFocus` parameter provides a better alternative.\nSetting this parameter to 1 requests that the solver work harder to try to avoid solutions that exploit integrality\ntolerances. More precisely, the solver tries to find solutions that are still (nearly) feasible if all integer variables\nare rounded to exact integral values. We should say that the solver won't always succeed in finding such solutions, and\nthat this setting introduces a modest performance penalty, but the setting will significantly reduce the frequency and\nmagnitude of such violations.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/integralityfocus.html).\n"] IntegralityFocus , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ MAXINT\n\n\nNumber of nodes to explore in the minimum relaxation heuristic. Note that this heuristic is only applied at the end of\nthe MIP root, and only when no other root heuristic finds a feasible solution.\n\nThis heuristic is quite expensive, and generally produces poor quality solutions. You should generally only use it if\nother means, including exploration of the tree with default settings, fail to produce a feasible solution.\n\nThe default value automatically chooses whether to apply the heuristic. It will only rarely choose to do so.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/minrelnodes.html).\n"] MinRelNodes , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ 3\n\n\nThe `MIPFocus` parameter allows you to modify your high-level solution strategy, depending on your goals. By default,\nthe Gurobi MIP solver strikes a balance between finding new feasible solutions and proving that the current solution is\noptimal. If you are more interested in finding feasible solutions quickly, you can select MIPFocus=1. If you believe the\nsolver is having no trouble finding good quality solutions, and wish to focus more attention on proving optimality,\nselect MIPFocus=2. If the best objective bound is moving very slowly (or not at all), you may want to try MIPFocus=3 to\nfocus on the bound.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/mipfocus.html).\n"] MIPFocus , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nAlgorithm used for MIP node relaxations (except for the initial root node relaxation, see Method). Options are:\n-1=automatic, 0=primal simplex, 1=dual simplex, and 2=barrier. Note that barrier is not an option for MIQP node\nrelaxations.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/nodemethod.html).\n"] NodeMethod , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ MAXINT\n\n\nNumber of passes of the feasibility pump heuristic. Note that this heuristic is only applied at the end of the MIP root.\n\nThis heuristic is quite expensive, and generally produces poor quality solutions. You should generally only use it if\nother means, including exploration of the tree with default settings, fail to produce a feasible solution.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/pumppasses.html).\n"] PumpPasses , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ MAXINT\n\n\nFrequency of the `RINS` heuristic. Default value (-1) chooses automatically. A value of 0 shuts off RINS. A positive\nvalue n applies `RINS` at every n-th node of the MIP search tree.\n\nIncreasing the frequency of the `RINS` heuristic shifts the focus of the MIP search away from proving optimality, and\ntowards finding good feasible solutions. We recommend that you try MIPFocus, ImproveStartGap, or `ImproveStartTime`\nbefore experimenting with this parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/rins.html).\n"] RINS , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -3\n- __Maximum:__ MAXINT\n\n\nThis parameter limits the number of branch-and-bound nodes explored when completing a partial MIP start. The default\nvalue of -1 uses the value of the `SubMIPNodes` parameter. A value of -2 means to only check full MIP starts for\nfeasibility and to ignore partial MIP starts. A value of -3 shuts off MIP start processing entirely. Non-negative values\nare node limits.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/startnodelimit.html).\n"] StartNodeLimit , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 500\n- __Minimum:__ 0\n- __Maximum:__ MAXINT\n\n\nLimits the number of nodes explored by MIP-based heuristics (such as RINS). Exploring more nodes can produce better\nsolutions, but it generally takes longer.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/submipnodes.html).\n"] SubMIPNodes , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls symmetry detection. A value of -1 corresponds to an automatic setting. Other options are off (0), conservative\n(1), or aggressive (2).\n\n`Symmetry` can impact a number of different parts of the algorithm, including presolve, the MIP tree search, and the LP\nsolution process. Default settings are quite effective, so changing the value of this parameter rarely produces a\nsignificant benefit.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/symmetry.html).\n"] Symmetry , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 3\n\n\nControls the branch variable selection strategy. The default -1 setting makes an automatic choice, depending on problem\ncharacteristics. Available alternatives are Pseudo Reduced Cost Branching (0), Pseudo Shadow Price Branching (1),\nMaximum Infeasibility Branching (2), and Strong Branching (3).\n\nChanging the value of this parameter rarely produces a significant benefit.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/varbranch.html).\n"] VarBranch , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ MAXINT\n\n\nWhen querying attribute Xn, ObjNVal, or PoolObjVal to retrieve an alternate MIP solution, this parameter determines\nwhich alternate solution is retrieved. The value of this parameter should be less than the value of the SolCount\nattribute.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/solutionnumber.html).\n"] SolutionNumber , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ MAXINT\n\n\nNumber of nodes to explore in the zero objective heuristic. Note that this heuristic is only applied at the end of the\nMIP root, and only when no other root heuristic finds a feasible solution.\n\nThis heuristic is quite expensive, and generally produces poor quality solutions. You should generally only use it if\nother means, including exploration of the tree with default settings, fail to produce a feasible solution.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/zeroobjnodes.html).\n"] ZeroObjNodes , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 3\n\n\nGlobal cut aggressiveness setting. Use value 0 to shut off cuts, 1 for moderate cut generation, 2 for aggressive cut\ngeneration, and 3 for very aggressive cut generation. This parameter is overridden by the parameters that control\nindividual cut types (e.g., CliqueCuts).\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/cuts.html).\n"] Cuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls clique cut generation. Use 0 to disable these cuts, 1 for moderate cut generation, or 2 for aggressive cut\ngeneration. The default -1 value choose automatically. Overrides the `Cuts` parameter.\n\nWe have observed that setting this parameter to its aggressive setting can produce a significant benefit for some large\nset partitioning models.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/cliquecuts.html).\n"] CliqueCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls cover cut generation. Use 0 to disable these cuts, 1 for moderate cut generation, or 2 for aggressive cut\ngeneration. The default -1 value chooses automatically. Overrides the `Cuts` parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/covercuts.html).\n"] CoverCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls flow cover cut generation. Use 0 to disable these cuts, 1 for moderate cut generation, or 2 for aggressive cut\ngeneration. The default -1 value chooses automatically. Overrides the `Cuts` parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/flowcovercuts.html).\n"] FlowCoverCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls flow path cut generation. Use 0 to disable these cuts, 1 for moderate cut generation, or 2 for aggressive cut\ngeneration. The default -1 value chooses automatically. Overrides the `Cuts` parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/flowpathcuts.html).\n"] FlowPathCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls GUB cover cut generation. Use 0 to disable these cuts, 1 for moderate cut generation, or 2 for aggressive cut\ngeneration. The default -1 value chooses automatically. Overrides the `Cuts` parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/gubcovercuts.html).\n"] GUBCoverCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls implied bound cut generation. Use 0 to disable these cuts, 1 for moderate cut generation, or 2 for aggressive\ncut generation. The default -1 value chooses automatically. Overrides the `Cuts` parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/impliedcuts.html).\n"] ImpliedCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls projected implied bound cut generation. Use 0 to disable these cuts, 1 for moderate cut generation, or 2 for\naggressive cut generation. The default -1 value chooses automatically. Overrides the `Cuts` parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/projimpliedcuts.html).\n"] ProjImpliedCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls MIP separation cut generation. Use 0 to disable these cuts, 1 for moderate cut generation, or 2 for aggressive\ncut generation. The default -1 value chooses automatically. Overrides the `Cuts` parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/mipsepcuts.html).\n"] MIPSepCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls Mixed Integer Rounding (MIR) cut generation. Use 0 to disable these cuts, 1 for moderate cut generation, or 2\nfor aggressive cut generation. The default -1 value chooses automatically. Overrides the `Cuts` parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/mircuts.html).\n"] MIRCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls Strong Chvtal-Gomory (Strong-CG) cut generation. Use 0 to disable these cuts, 1 for moderate cut generation,\nor 2 for aggressive cut generation. The default -1 value chooses automatically. Overrides the `Cuts` parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/strongcgcuts.html).\n"] StrongCGCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls mod-k cut generation. Use 0 to disable these cuts, 1 for moderate cut generation, or 2 for aggressive cut\ngeneration. The default -1 value chooses automatically. Overrides the `Cuts` parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/modkcuts.html).\n"] ModKCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls zero-half cut generation. Use 0 to disable these cuts, 1 for moderate cut generation, or 2 for aggressive cut\ngeneration. The default -1 value chooses automatically. Overrides the `Cuts` parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/zerohalfcuts.html).\n"] ZeroHalfCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls network cut generation. Use 0 to disable these cuts, 1 for moderate cut generation, or 2 for aggressive cut\ngeneration. The default -1 value chooses automatically. Overrides the `Cuts` parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/networkcuts.html).\n"] NetworkCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls sub-MIP cut generation. Use 0 to disable these cuts, 1 for moderate cut generation, or 2 for aggressive cut\ngeneration. The default -1 value chooses automatically. Overrides the `Cuts` parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/submipcuts.html).\n"] SubMIPCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls infeasibility proof cut generation. Use 0 to disable these cuts, 1 for moderate cut generation, or 2 for\naggressive cut generation. The default -1 value chooses automatically. Overrides the `Cuts` parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/infproofcuts.html).\n"] InfProofCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls Relaxation Linearization Technique (RLT) cut generation. Use 0 to disable these cuts, 1 for moderate cut\ngeneration, or 2 for aggressive cut generation. The default -1 value chooses automatically. Overrides the `Cuts`\nparameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/rltcuts.html).\n"] RLTCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls relax-and-lift cut generation. Use 0 to disable these cuts, 1 for moderate cut generation, or 2 for aggressive\ncut generation. The default -1 value chooses automatically. Overrides the `Cuts` parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/relaxliftcuts.html).\n"] RelaxLiftCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls Boolean Quadric Polytope (BQP) cut generation. Use 0 to disable these cuts, 1 for moderate cut generation, or 2\nfor aggressive cut generation. The default -1 value chooses automatically. Overrides the `Cuts` parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/bqpcuts.html).\n"] BQPCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls PSD cut generation. Use 0 to disable these cuts, 1 for moderate cut generation, or 2 for aggressive cut\ngeneration. The default -1 value chooses automatically. Overrides the `Cuts` parameter.\n\nNote: Only affects models with nonconvex quadratic expressions in the objective or constraints\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/psdcuts.html).\n"] PSDCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ MAXINT\n\n\nA non-negative value indicates the maximum number of constraint aggregation passes performed during cut generation.\nOverrides the `Cuts` parameter.\n\nChanging the value of this parameter rarely produces a significant benefit.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/cutaggpasses.html).\n"] CutAggPasses , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ MAXINT\n\n\nA non-negative value indicates the maximum number of cutting plane passes performed during root cut generation. The\ndefault value chooses the number of cut passes automatically.\n\nYou should experiment with different values of this parameter if you notice the MIP solver spending significant time on\nroot cut passes that have little impact on the objective bound.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/cutpasses.html).\n"] CutPasses , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ MAXINT\n\n\nA non-negative value indicates the maximum number of Gomory cut passes performed. Overrides the `Cuts` parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/gomorypasses.html).\n"] GomoryPasses , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 60\n- __Minimum:__ 1\n- __Maximum:__ MAXINT\n\n\nNetwork time-out for Compute Server and token server (in seconds). If the client program is unable to contact the server\nfor more than the specified amount of time, the client will quit with a network error.\n\nRefer to the Gurobi Remote Services Reference Manual for more information on starting Compute Server jobs.\n\nYou must set this parameter using an empty environment. Changing the parameter after your environment has been created\nwill have no effect.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/servertimeout.html).\n"] ServerTimeout , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ -100\n- __Maximum:__ 100\n\n\nThe priority of the Compute Server job. Priorities must be between -100 and 100, with a default value of 0 (by\nconvention). Higher priority jobs are chosen from the server job queue before lower priority jobs. A job with priority\n100 runs immediately, bypassing the job queue and ignoring the job limit on the server. You should exercise caution with\npriority 100 jobs, since they can severely overload a server, which can cause jobs to fail, and in extreme cases can\ncause the server to crash.\n\nRefer to the Gurobi Remote Services Reference Manual for more information on starting Compute Server jobs.\n\nYou must set this parameter through either a gurobi.lic file (using PRIORITY=n) or an empty environment. Changing the\nparameter after your environment has been created will have no effect.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/cspriority.html).\n"] CSPriority , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ MAXINT\n\n\nThis parameter allows you to set a limit on how long a Compute Server job can sit idle before the server kills the job\n(in seconds). A job is considered idle if the server is not currently performing an optimization and the client has not\nissued any additional commands.\n\nThe default value will allow a job to sit idle indefinitely in all but one circumstance. Currently the only exception is\nthe Gurobi Instant Cloud, where the default setting will automatically impose a 30 minute idle time limit (1800\nseconds). If you are using an Instant Cloud pool, the actual value will be the maximum between this parameter value and\nthe idle timeout defined by the pool.\n\nYou must set this parameter through either a gurobi.lic file (using IDLETIMEOUT=n) or an empty environment. Changing the\nparameter after your environment has been created will have no effect.\n\nRefer to the Gurobi Remote Services Reference Manual for more information on starting Compute Server jobs.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/csidletimeout.html).\n"] CSIdleTimeout , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ 1\n\n\nIndicates whether the Remote Services cluster is using insecure mode in the TLS (Transport Layer Security). Set this to\n0 unless your server administrator tells you otherwise.\n\nRefer to the Gurobi Remote Services Reference Manual for more information on starting Compute Server jobs.\n\nYou must set this parameter through either a gurobi.lic file (using CSTLSINSECURE) or an empty environment. Changing the\nparameter after your environment has been created will have no effect.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/cstlsinsecure.html).\n"] CSTLSInsecure , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 41954\n- __Minimum:__ 0\n- __Maximum:__ 65536\n\n\nPort to use when connecting to the Gurobi token server. You should only change this if your network administrator tells\nyou to.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/tsport.html).\n"] TSPort , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ 1\n\n\nWhen set to 1, enable the local creation of models, and later submit batch-optimization jobs to the Cluster Manager. See\nthe Batch Optimization section for more details. Note that if `CSBatchMode` is enabled, only batch-optimization calls\nare allowed.\n\nYou must set this parameter through either a gurobi.lic file (using CSBATCHMODE=1) or an empty environment. Changing the\nparameter after your environment has been started will result in an error.\n\nNote: Cluster Manager only\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/csbatchmode.html).\n"] CSBatchMode , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ 3\n\n\nTurns logging on or off for Compute Server. Options are off (0), only error messages (1), information and error messages\n(2), or (3) verbose, information, and error messages.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/csclientlog.html).\n"] CSClientLog , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 1\n- __Minimum:__ 0\n- __Maximum:__ 1\n\n\nEnables or disables aggregation in presolve. In rare instances, aggregation can lead to an accumulation of numerical\nerrors. Turning it off can sometimes improve solution accuracy.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/aggregate.html).\n"] Aggregate , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ MAXINT\n\n\nControls the amount of fill allowed during presolve aggregation. Larger values generally lead to presolved models with\nfewer rows and columns, but with more constraint matrix non-zeros.\n\nThe default value chooses automatically, and usually works well.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/aggfill.html).\n"] AggFill , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 1\n- __Minimum:__ 1\n- __Maximum:__ MAXINT\n\n\nThis parameter enables the concurrent MIP solver. When the parameter is set to value n, the MIP solver performs n\nindependent MIP solves in parallel, with different parameter settings for each. Optimization terminates when the first\nsolve completes.\n\nBy default, Gurobi chooses the parameter settings used for each independent solve automatically. You can create\nconcurrent environments to choose your own parameter settings (refer to the concurrent optimization section for\ndetails). The intent of concurrent MIP solving is to introduce additional diversity into the MIP search. This approach\ncan sometimes solve models much faster than applying all available threads to a single MIP solve, especially on very\nlarge parallel machines.\n\nThe concurrent MIP solver divides available threads evenly among the independent solves. For example, if you have 6\nthreads available and you set `ConcurrentMIP` to 2, the concurrent MIP solver will allocate 3 threads to each\nindependent solve. Note that the number of independent solves launched will not exceed the number of available threads.\n\nThe concurrent MIP solver produces a slightly different log from the standard MIP solver, and provides different\ncallbacks as well. Please refer to the concurrent optimizer discussion for additional details.\n\nConcurrent MIP is not deterministic. If runtimes for different independent solves are very similar, and if the model has\nmultiple optimal solutions, you may get slightly different results from multiple runs on the same model.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/concurrentmip.html).\n"] ConcurrentMIP , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ MAXINT\n\n\nEnables distributed concurrent optimization, which can be used to solve LP or MIP models on multiple machines. A value\nof n causes the solver to create n independent models, using different parameter settings for each. Each of these models\nis sent to a distributed worker for processing. Optimization terminates when the first solve completes. Use the\n`ComputeServer` parameter to indicate the name of the cluster where you would like your distributed concurrent job to\nrun (or use `WorkerPool` if your client machine will act as manager and you just need a pool of workers).\n\nBy default, Gurobi chooses the parameter settings used for each independent solve automatically. You can create\nconcurrent environments to choose your own parameter settings (refer to the concurrent optimization section for\ndetails). The intent of concurrent MIP solving is to introduce additional diversity into the MIP search. By bringing the\nresources of multiple machines to bear on a single model, this approach can sometimes solve models much faster than a\nsingle machine.\n\nThe distributed concurrent solver produces a slightly different log from the standard solver, and provides different\ncallbacks as well. Please refer to the Distributed Algorithms section of the Gurobi Remote Services Reference Manual for\nadditional details.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/concurrentjobs.html).\n"] ConcurrentJobs , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 5\n- __Minimum:__ 1\n- __Maximum:__ MAXINT\n\n\nDetermines the frequency at which log lines are printed (in seconds).\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/displayinterval.html).\n"] DisplayInterval , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ MAXINT\n\n\nEnables distributed MIP. A value of n causes the MIP solver to divide the work of solving a MIP model among n machines.\nUse the `ComputeServer` parameter to indicate the name of the cluster where you would like your distributed MIP job to\nrun (or use `WorkerPool` if your client machine will act as manager and you just need a pool of workers).\n\nThe distributed MIP solver produces a slightly different log from the standard MIP solver, and provides different\ncallbacks as well. Please refer to the Distributed Algorithms section of the Gurobi Remote Services Reference Manual for\nadditional details.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/distributedmipjobs.html).\n"] DistributedMIPJobs , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 1\n- __Minimum:__ 0\n- __Maximum:__ 1\n\n\nDetermines whether dual reductions are performed in presolve. You should disable these reductions if you received an\noptimization status of INF_OR_UNBD and would like a more definitive conclusion.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/dualreductions.html).\n"] DualReductions , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 3\n\n\nChooses the IIS method to use. `Method` 0 is often faster, while method 1 can produce a smaller IIS. `Method` 2 ignores\nthe bound constraints. `Method` 3 will return the IIS for the LP relaxation of a MIP model if the relaxation is\ninfeasible, even though the result may not be minimal when integrality constraints are included. The default value of -1\nchooses automatically.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/iismethod.html).\n"] IISMethod , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ 1\n\n\nDetermines whether simplex (and crossover) will compute additional information when a model is determined to be\ninfeasible or unbounded. Set this parameter if you want to query the unbounded ray for unbounded models (through the\nUnbdRay attribute), or the infeasibility proof for infeasible models (through the FarkasDual and FarkasProof\nattributes).\n\nNote that if a model is found to be either infeasible or unbounded, and you simply want to know which one it is, you\nshould use the `DualReductions` parameter instead. It performs much less additional computation.\n\nNote: LP only\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/infunbdinfo.html).\n"] InfUnbdInfo , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ 1\n\n\nThis parameter controls the amount of detail included in a JSON solution. For example, when this parameter is set to 1,\nthe JSON string will contain data for all of the variables, even those with solution value 0.\n\nFor a precise description of the contents of the resulting JSON string, please refer to the JSON solution format\nsection.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/jsonsoldetail.html).\n"] JSONSolDetail , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ 1\n\n\nPrograms that add lazy constraints through a callback must set this parameter to value 1. The parameter tells the Gurobi\nalgorithms to avoid certain reductions and transformations that are incompatible with lazy constraints.\n\nNote that if you use lazy constraints by setting the Lazy attribute (and not through a callback), there's no need to set\nthis parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/lazyconstraints.html).\n"] LazyConstraints , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 1\n- __Minimum:__ 0\n- __Maximum:__ 1\n\n\nEnables or disables console logging. Use `OutputFlag` to shut off all logging.\n\nNote that this refers to all the output of Gurobi to the console including the various display and print functions\nprovided by the API in interactive environments. It also disables logging on the remote side of Instant Cloud or Compute\nServer environments.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/logtoconsole.html).\n"] LogToConsole , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 1\n\n\nControls the method used to solve MIQCP models. Value 1 uses a linearized, outer-approximation approach, while value 0\nsolves continuous QCP relaxations at each node. The default setting (-1) chooses automatically.\n\nNote: Only affects MIQCP models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/miqcpmethod.html).\n"] MIQCPMethod , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nSets the strategy for handling non-convex quadratic objectives or non-convex quadratic constraints. With setting 0, an\nerror is reported if the original user model contains non-convex quadratic constructs. With setting 1, an error is\nreported if non-convex quadratic constructs could not be discarded or linearized during presolve. With setting 2, non-\nconvex quadratic problems are solved by means of translating them into bilinear form and applying spatial branching. The\ndefault -1 setting is currently equivalent to 1, and may change in future releases to be equivalent to 2.\n\nNote: Only affects QP, QCP, MIQP, and MIQCP models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/nonconvex.html).\n"] NonConvex , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ 3\n\n\nThe `NumericFocus` parameter controls the degree to which the code attempts to detect and manage numerical issues. The\ndefault setting (0) makes an automatic choice, with a slight preference for speed. Settings 1-3 increasingly shift the\nfocus towards being more careful in numerical computations. With higher values, the code will spend more time checking\nthe numerical accuracy of intermediate results, and it will employ more expensive techniques in order to avoid potential\nnumerical issues.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/numericfocus.html).\n"] NumericFocus , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 1\n- __Minimum:__ 0\n- __Maximum:__ 1\n\n\nEnables or disables solver output. Use `LogFile` and `LogToConsole` for finer-grain control. Setting `OutputFlag` to 0\nis equivalent to setting `LogFile` to \"\" and `LogToConsole` to 0.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/outputflag.html).\n"] OutputFlag , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ 1\n\n\nShuts off a few reductions in order to allow presolve to transform any constraint on the original model into an\nequivalent constraint on the presolved model. You should consider setting this parameter to 1 if you are using callbacks\nto add your own cuts. A cut that cannot be applied to the presolved model will be silently ignored. The impact on the\nsize of the presolved problem is usually small.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/precrush.html).\n"] PreCrush , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 1\n\n\nControls the presolve dependent row reduction, which eliminates linearly dependent constraints from the constraint\nmatrix. The default setting (-1) applies the reduction to continuous models but not to MIP models. Setting 0 turns the\nreduction off for all models. Setting 1 turns it on for all models.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/predeprow.html).\n"] PreDepRow , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls whether presolve forms the dual of a continuous model. Depending on the structure of the model, solving the\ndual can reduce overall solution time. The default setting uses a heuristic to decide. Setting 0 forbids presolve from\nforming the dual, while setting 1 forces it to take the dual. Setting 2 employs a more expensive heuristic that forms\nboth the presolved primal and dual models (on two threads), and heuristically chooses one of them.\n\nNote: LP only\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/predual.html).\n"] PreDual , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ MAXINT\n\n\nLimits the number of passes performed by presolve. The default setting (-1) chooses the number of passes automatically.\nYou should experiment with this parameter when you find that presolve is consuming a large fraction of total solve time.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/prepasses.html).\n"] PrePasses , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls presolve Q matrix linearization. Binary variables in quadratic expressions provide some freedom to state the\nsame expression in multiple different ways. Options 1 and 2 of this parameter attempt to linearize quadratic constraints\nor a quadratic objective, replacing quadratic terms with linear terms, using additional variables and linear\nconstraints. This can potentially transform an MIQP or MIQCP model into an MILP. Option 1 focuses on producing an MILP\nreformulation with a strong LP relaxation, with a goal of limiting the size of the MIP search tree. Option 2 aims for a\ncompact reformulation, with a goal of reducing the cost of each node. Option 0 attempts to leave Q matrices unmodified;\nit won't add variables or constraints, but it may still perform adjustments on quadratic objective functions to make\nthem positive semi-definite (PSD). The default setting (-1) chooses automatically.\n\nNote: Only affects MIQP and MIQCP models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/preqlinearize.html).\n"] PreQLinearize , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls the presolve level. A value of -1 corresponds to an automatic setting. Other options are off (0), conservative\n(1), or aggressive (2). More aggressive application of presolve takes more time, but can sometimes lead to a\nsignificantly tighter model.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/presolve.html).\n"] Presolve , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 1\n\n\nControls the presolve sparsify reduction. This reduction can sometimes significantly reduce the number of non-zero\nvalues in the presolved model. Value 0 shuts off the reduction, while value 1 forces it on. The default value of -1\nchooses automatically.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/presparsify.html).\n"] PreSparsify , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nDetermines the format of the presolved version of an MIQCP model. Option 0 leaves the model in MIQCP form, so the\nbranch-and-cut algorithm will operate on a model with arbitrary quadratic constraints. Option 1 always transforms the\nmodel into MISOCP form; quadratic constraints are transformed into second-order cone constraints. Option 2 always\ntransforms the model into disaggregated MISOCP form; quadratic constraints are transformed into rotated cone\nconstraints, where each rotated cone contains two terms and involves only three variables.\n\nThe default setting (-1) choose automatically. The automatic setting works well, but there are cases where forcing a\ndifferent form can be beneficial.\n\nNote: Only affects MIQCP models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/premiqcpform.html).\n"] PreMIQCPForm , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ 1\n\n\nDetermines whether dual variable values are computed for QCP models. Computing them can add significant time to the\noptimization, so you should only set this parameter to 1 if you need them.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/qcpdual.html).\n"] QCPDual , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ 1\n\n\nEnables API call recording. When enabled, Gurobi will write one or more files (named gurobi000.grbr or similar) that\ncapture the sequence of Gurobi commands that your program issued. This file can subsequently be replayed using the\nGurobi command-line tool. Replaying the file will repeat the exact same sequence of commands, and when completed will\nshow the time spent in Gurobi API routines, the time spent in Gurobi algorithms, and will indicate whether any Gurobi\nenvironments or models were leaked by your program. Replay files are particularly useful in tech support situations.\nThey provide an easy way to relay to Gurobi tech support the exact sequence of Gurobi commands that led to a question or\nissue.\n\nThis parameter must be set before starting an empty environment (or in a gurobi.env file). All Gurobi commands will be\nrecorded until the environment is freed or the program ends.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/record.html).\n"] Record , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ MAXINT\n\n\nModifies the random number seed. This acts as a small perturbation to the solver, and typically leads to different\nsolution paths.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/seed.html).\n"] Seed , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ The number of virtual processors available to the\nprocess running Gurobi\n\n\nControls the number of threads to apply to parallel algorithms (concurrent LP, parallel barrier, parallel MIP, etc.).\nThe default value of 0 is an automatic setting. It will generally use as many threads as there are virtual processors.\nThe number of virtual processors may exceed the number of cores due to hyperthreading or other similar hardware\nfeatures.\n\nWhile you will generally get the best performance by using all available cores in your machine, there are a few\nexceptions. One is of course when you are sharing a machine with other jobs. In this case, you should select a thread\ncount that doesn't oversubscribe the machine.\n\nWe have also found that certain classes of MIP models benefit from reducing the thread count, often all the way down to\none thread. Starting multiple threads introduces contention for machine resources. For classes of models where the first\nsolution found by the MIP solver is almost always optimal, and that solution isn't found at the root, it is often better\nto allow a single thread to explore the search tree uncontested.\n\nAnother situation where reducing the thread count can be helpful is when memory is tight. Each thread can consume a\nsignificant amount of memory.\n\nWe've made the pragmatic choice to impose a soft limit of 32 threads for the automatic setting (0). If your machine has\nmore, and you find that using more increases performance, you should feel free to set the parameter to a larger value.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/threads.html).\n"] Threads , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ MAXINT\n\n\nThe tuning tool often finds multiple parameter sets that produce better results than the baseline settings. This\nparameter controls how many of these sets should be retained when tuning is complete. The default value retains the best\nresults that were found for each count of changed parameters. In other words, it retains the best result for one changed\nparameter, for two changed parameter, etc. Results that aren't on the efficient frontier are discard.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/tuneresults.html).\n"] TuneResults , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 3\n\n\nModifies the tuning criterion for the tuning tool. The primary tuning criterion is always to minimize the runtime\nrequired to find a proven optimal solution. However, for MIP models that don't solve to optimality within the specified\ntime limit, a secondary criterion is needed. Set this parameter to 1 to use the optimality gap as the secondary\ncriterion. Choose a value of 2 to use the objective of the best feasible solution found. Choose a value of 3 to use the\nbest objective bound. Choose 0 to ignore the secondary criterion and focus entirely on minimizing the time to find a\nproven optimal solution. The default value of -1 chooses automatically.\n\nNote that for multi-objective problems value 1 and 3 are unsupported. See the Multiple Objectives section for more\ndetails on this.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/tunecriterion.html).\n"] TuneCriterion , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ MAXINT\n\n\nPerformance on a MIP model can sometimes experience significant variations due to random effects. As a result, the\ntuning tool may return parameter sets that improve on the baseline only due to randomness. This parameter allows you to\nperform multiple solves for each parameter set, using different `Seed` values for each, in order to reduce the influence\nof randomness on the results. The default value of 0 indicates an automatic choice that depends on model\ncharacteristics.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/tunetrials.html).\n"] TuneTrials , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 2\n- __Minimum:__ 0\n- __Maximum:__ 3\n\n\nControls the amount of output produced by the tuning tool. Level 0 produces no output; level 1 produces tuning summary\noutput only when a new best parameter set is found; level 2 produces tuning summary output for each parameter set that\nis tried; level 3 produces tuning summary output, plus detailed solver output, for each parameter set tried.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/tuneoutput.html).\n"] TuneOutput , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ MAXINT\n\n\nEnables distributed parallel tuning, which can significantly increase the performance of the tuning tool. A value of n\ncauses the tuning tool to distribute tuning work among n parallel jobs. These jobs are distributed among a set of\nmachines. Use the `WorkerPool` parameter to provide a distributed worker cluster.\n\nNote that distributed tuning is most effective when the worker machines have similar performance. Distributed tuning\ndoesn't attempt to normalize performance by server, so it can incorrectly attribute a boost in performance to a\nparameter change when the associated setting is tried on a worker that is significantly faster than the others.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/tunejobs.html).\n"] TuneJobs , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 1\n- __Minimum:__ 0\n- __Maximum:__ 1\n\n\nDetermines how newly added variables and linear constraints are handled. The default setting (1) allows you to use new\nvariables and constraints immediately for building or modifying the model. A setting of 0 requires you to call update\nbefore these can be used.\n\nSince the vast majority of programs never query Gurobi for details about the optimization models they build, the default\nsetting typically removes the need to call update, or even be aware of the details of our lazy update approach for\nhandling model modifications. However, these details will show through when you try to query modified model information.\n\nIn the Gurobi interface, model modifications (bound changes, right-hand side changes, objective changes, etc.) are\nplaced in a queue. These queued modifications are applied to the model at three times: when you call update, when you\ncall optimize, or when you call write to write the model to disk. When you query information about the model, the result\nwill depend on both whether that information was modified and when it was modified. In particular, no matter what\nsetting of `UpdateMode` you use, if the modification is sitting in the queue, you'll get the result from before the\nmodification.\n\nTo expand on this a bit, all attribute modifications are actually placed in a queue. This includes attributes that may\nnot traditionally be viewed as being part of the model, including things like variable branching priorities, constraint\nbasis statuses, etc. Querying the values of these attributes will return their previous values if subsequent\nmodifications are still in the queue.\n\nThe only potential benefit to changing the parameter to 0 is that in unusual cases this setting may allow simplex to\nmake more aggressive use of warm-start information after a model modification.\n\nIf you want to change this parameter, you need to set it as soon as you create your Gurobi environment.\n\nNote that you still need to call update to modify an attribute on an SOS constraint, quadratic constraint, or general\nconstraint.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/updatemode.html).\n"] UpdateMode , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ MAXINT\n\n\nWhen working with multiple objectives, this parameter selects the index of the objective you want to work with. When you\nquery or modify an attribute associated with multiple objectives (ObjN, ObjNVal, etc.), the `ObjNumber` parameter will\ndetermine which objective is actually affected. The value of this parameter should be less than the value of the NumObj\nattribute (which captures the number of objectives in the model).\n\nPlease refer to the discussion of Multiple Objectives for more information on the use of alternative objectives.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/objnumber.html).\n"] ObjNumber , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nWhen solving a continuous multi-objective model using a hierarchical approach, the model is solved once for each\nobjective. The algorithm used to solve for the highest priority objective is controlled by the `Method` parameter. This\nparameter determines the algorithm used to solve for subsequent objectives. As with the `Method` parameters, values of 0\nand 1 use primal and dual simplex, respectively. A value of 2 indicates that warm-start information from previous solves\nshould be discarded, and the model should be solved from scratch (using the algorithm indicated by the `Method`\nparameter). The default setting of -1 usually chooses primal simplex.\n\nNote: Only affects continuous multi-objective models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/multiobjmethod.html).\n"] MultiObjMethod , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls the initial presolve level used for multi-objective models. Value 0 disables the initial presolve, value 1\napplies presolve conservatively, and value 2 applies presolve aggressively. The default -1 value usually applies\npresolve conservatively. Aggressive presolve may increase the chance of the objective values being slightly different\nthan those for other options.\n\nNote: Only affects multi-objective models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/multiobjpre.html).\n"] MultiObjPre , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ MAXINT\n\n\nWhen working with multiple scenarios, this parameter selects the index of the scenario you want to work with. When you\nquery or modify an attribute associated with multiple scenarios (ScenNLB, ScenNUB, ScenNObj, ScenNRHS, etc.), the\n`ScenarioNumber` parameter will determine which scenario is actually affected. The value of this parameter should be\nless than the value of the NumScenarios attribute (which captures the number of scenarios in the model).\n\nPlease refer to the discussion of Multiple Scenarios for more information on the use of alternative scenarios.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/scenarionumber.html).\n"] ScenarioNumber , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 10\n- __Minimum:__ 1\n- __Maximum:__ MAXINT\n\n\nDetermines how many MIP solutions are stored. For the default value of PoolSearchMode, these are just the solutions that\nare found along the way in the process of exploring the MIP search tree. For other values of PoolSearchMode, this\nparameter sets a target for how many solutions to find, so larger values will impact performance.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/poolsolutions.html).\n"] PoolSolutions , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ 2\n\n\nSelects different modes for exploring the MIP search tree. With the default setting (PoolSearchMode=0), the MIP solver\ntries to find an optimal solution to the model. It keeps other solutions found along the way, but those are incidental.\nBy setting this parameter to a non-default value, the MIP search will continue after the optimal solution has been found\nin order to find additional, high-quality solutions. With a non-default value (PoolSearchMode=1 or PoolSearchMode=2),\nthe MIP solver will try to find n solutions, where n is determined by the value of the `PoolSolutions` parameter. With a\nsetting of 1, there are no guarantees about the quality of the extra solutions, while with a setting of 2, the solver\nwill find the n best solutions. The cost of the solve will increase with increasing values of this parameter.\n\nOnce optimization is complete, the PoolObjBound attribute can be used to evaluate the quality of the solutions that were\nfound. For example, a value of PoolObjBound=100 indicates that there are no other solutions with objective better 100,\nand thus that any known solutions with objective better than 100 are better than any as-yet undiscovered solutions.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/poolsearchmode.html).\n"] PoolSearchMode , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ 1\n\n\nThis parameter affects how Gurobi deals with names. If set to 1, subsequent calls to add variables or constraints to the\nmodel will ignore the associated names. Names for objectives and the model will also be ignored. In addition, subsequent\ncalls to modify name attributes will have no effect. Note that variables or constraints that had names at the point this\nparameter was changed to 1 will retain their names. If you wish to discard all name information, you should set this\nparameter to 1 before adding variables or constraints to the model.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/ignorenames.html).\n"] IgnoreNames , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ -1\n- __Maximum:__ MAXINT\n\n\nThis parameter selects the index of the MIP start you want to work with. When you modify a MIP start value (using the\nStart attribute) the `StartNumber` parameter will determine which MIP start is actually affected. The value of this\nparameter should be less than the value of the NumStart attribute (which captures the number of MIP starts in the\nmodel).\n\nThe special value -1 is meant to append new MIP start to a model, but querying a MIP start when `StartNumber` is -1 will\nresult in an error.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/startnumber.html).\n"] StartNumber , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 15\n- __Minimum:__ 0\n- __Maximum:__ 31\n\n\nSetting the Partition attribute on at least one variable in a model enables the partitioning heuristic, which uses\nlarge-neighborhood search to try to improve the current incumbent solution.\n\nThis parameter determines where that heuristic runs. Options are:\n\nBefore the root relaxation is solved (16)\n\nAt the start of the root cut loop (8)\n\nAt the end of the root cut loop (4)\n\nAt the nodes of the branch-and-cut search (2)\n\nWhen the branch-and-cut search terminates (1)\n\nThe parameter value is a bit vector, where each bit turns the heuristic on or off at that place. The numerical values\nnext to the options listed above indicate which bit controls the corresponding option. Thus, for example, to enable the\nheuristic at the beginning and end of the root cut loop (and nowhere else), you would set the 8 bit and the 4 bit to 1,\nwhich would correspond to a parameter value of 12.\n\nThe default value of 15 indicates that we enable every option except the first one listed above.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/partitionplace.html).\n"] PartitionPlace , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ -2\n- __Maximum:__ MAXINT\n\n\nThis parameter sets the strategy used for performing a piecewise-linear approximation of a function constraint. There\nare a few options:\n\n`FuncPieces` >= 2: Sets the number of pieces; pieces are equal width.\n\n`FuncPieces` = 1: Uses a fixed width for each piece; the actual width is provided in the `FuncPieceLength` parameter.\n\n`FuncPieces` = -1: Bounds the absolute error of the approximation; the error bound is provided in the `FuncPieceError`\nparameter.\n\n`FuncPieces` = -2: Bounds the relative error of the approximation; the error bound is provided in the `FuncPieceError`\nparameter.\n\nThis parameter only applies to function constraints whose `FuncPieces` attribute has been set to $0$.\n\nSee the discussion of function constraints for more information.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/funcpieces2.html).\n"] FuncPieces , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 1\n- __Minimum:__ 0\n- __Maximum:__ 2\n\n\nControls whether and how Gurobi uses warm start information for an LP optimization. The non default setting of 2 is\nparticularly useful for communicating advanced start information while retaining the performance benefits of presolve. A\nwarm start can consist of any combination of basis statuses, a primal start vector, or a dual start vector. It is\nspecified using the attributes VBasis and CBasis or PStart and DStart on the original model.\n\nAs a general rule, setting this parameter to 0 ignores any start information and solves the model from scratch. Setting\nit to 1 (the default) uses the provided warm start information to solve the original, unpresolved problem, regardless of\nwhether presolve is enabled. Setting it to 2 uses the start information to solve the presolved problem, assuming that\npresolve is enabled. This involves mapping the solution of the original problem into an equivalent (or sometimes nearly\nequivalent) crushed solution of the presolved problem. If presolve is disabled, then setting 2 still prioritizes start\nvectors, while setting 1 prioritizes basis statuses. Taken together, the `LPWarmStart` parameter setting, the LP\nalgorithm specified by Gurobi's `Method` parameter, and the available advanced start information determine whether\nGurobi will use basis statuses only, basis statuses augmented with information from start vectors, or a basis obtained\nby applying the crossover method to the provided primal and dual start vectors to jump start the optimization.\n\nWhen Gurobi's `Method` parameter requests the barrier solver, primal and dual start vectors are prioritized over basis\nstatuses (but only if you provide both). These start vectors are fed to the crossover procedure. This is the same\ncrossover that is used to compute a basic solution from the interior solution produced by the core barrier algorithm,\nbut in this case crossover is started from arbitrary start vectors. If you set the `LPWarmStart` parameter to 1,\ncrossover will be invoked on the original model using the provided vectors. Any provided basis information will not be\nused in this case. If you set `LPWarmStart` to 2, crossover will be invoked on the presolved model using crushed start\nvectors. If you set the parameter to 2 and provide a basis but no start vectors, the basis will be used to compute the\ncorresponding primal and dual solutions on the original model. Those solutions will then be crushed and used as primal\nand dual start vectors for the crossover, which will then construct a basis for the presolved model. Note that for all\nof these settings and start combinations, no barrier algorithm iterations are performed.\n\nThe simplex algorithms provide more warm-starting options, With a parameter value of 1, simplex will start from a\nprovided basis, if available. Otherwise, it uses a provided start vector to refine the crash basis it computes. Primal\nsimplex will use PStart and dual simplex will use DStart in this refinement process.\n\nWith a value of 2, simplex will use the crushed start vector on the presolved model (PStart for primal simplex, DStart\nfor dual) to refine the crash basis. This is true regardless of whether the start is derived from start vectors or a\nstarting basis from the original model. The difference is that if you provide an advanced basis, the basis will be used\nto compute the corresponding primal and dual solutions on the original model from which the primal or dual start on the\npresolved model will be derived.\n\nNote: Only affects linear programming (LP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/lpwarmstart.html).\n"] LPWarmStart , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ MAXINT\n\n\nWhen using a WLS license, set this parameter to the license ID. You can retrieve this value from your account on the\nGurobi Web License Manager site.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/licenseid.html).\n"] LicenseID , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 2\n\n\nControls lift-and-project cut generation. Use 0 to disable these cuts, 1 for moderate cut generation, or 2 for\naggressive cut generation. The default -1 value chooses automatically. Overrides the `Cuts` parameter.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/liftprojectcuts.html).\n"] LiftProjectCuts , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 1\n- __Minimum:__ 0\n- __Maximum:__ 1\n\n\nThe NLP heuristic uses a non-linear barrier solver to find feasible solutions to non-convex quadratic models. It can\noften find solutions much more quickly than the alternative, but in some cases it can consume significant runtime\nwithout producing a solution.\n\nNote: Only affects non-convex quadratic models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/nlpheur.html).\n"] NLPHeur , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 3\n\n\nControls the automatic reformulation of SOS1 constraints. Such constraints can be handled directly by the MIP branch-\nand-cut algorithm, but they are often handled more efficiently by reformulating them using binary or integer variables.\nThere are several diffent ways to perform this reformulation; they differ in their size and strength. Smaller\nreformulations add fewer variables and constraints to the model. Stronger reformulations reduce the number of branch-\nand-cut nodes required to solve the resulting model.\n\nOptions 0 and 1 of this parameter encode an SOS1 constraint using a formulation whose size is linear in the number of\nSOS members. Option 0 uses a so-called multiple choice model. It usually produces an LP relaxation that is easier to\nsolve. Option 1 uses an incremental model. It often gives a stronger representation, reducing the amount of branching\nrequired to solve harder problems.\n\nOptions 2 and 3 of this parameter encode the SOS1 using a formulation of logarithmic size. They both only apply when all\nthe variables in the SOS1 are non-negative. Option 3 additionally requires that the sum of the variables in the SOS1 is\nequal to 1. Logarithmic formulations are often advantageous when the SOS1 constraint has a large number of members.\nOption 2 focuses on a formulation whose LP relaxation is easier to solve, while option 3 has better branching behaviour.\n\nThe default value of -1 chooses a reformulation for each SOS1 constraint automatically.\n\nNote that the reformulation of SOS1 constraints is also influenced by the `PreSOS1BigM` parameter. To shut off the\nreformulation entirely you should set that parameter to 0.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/presos1encoding.html).\n"] PreSOS1Encoding , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 3\n\n\nControls the automatic reformulation of SOS2 constraints. Such constraints can be handled directly by the MIP branch-\nand-cut algorithm, but they are often handled more efficiently by reformulating them using binary or integer variables.\nThere are several diffent ways to perform this reformulation; they differ in their size and strength. Smaller\nreformulations add fewer variables and constraints to the model. Stronger reformulations reduce the number of branch-\nand-cut nodes required to solve the resulting model.\n\nOptions 0 and 1 of this parameter encode an SOS2 constraint using a formulation whose size is linear in the the number\nof SOS members. Option 0 uses a so-called multiple choice model. It usually produces an LP relaxation that is easier to\nsolve. Option 1 uses an incremental model. It often gives a stronger representation, reducing the amount of branching\nrequired to solve harder problems.\n\nOptions 2 and 3 of this parameter encode the SOS2 using a formulation of logarithmic size. They both only apply when all\nthe variables in the SOS2 are non-negative. Option 3 additionally requires that the sum of the variables in the SOS2 is\nequal to 1. Logarithmic formulations are often advantageous when the SOS2 constraint has a large number of members.\nOption 2 focuses on a formulation whose LP relaxation is easier to solve, while option 3 has better branching behaviour.\n\nThe default value of -1 chooses a reformulation for each SOS2 constraint automatically.\n\nNote that the reformulation of SOS2 constraints is also influenced by the `PreSOS2BigM` parameter. To shut off the\nreformulation entirely you should set that parameter to 0.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/presos2encoding.html).\n"] PreSOS2Encoding , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ -1\n- __Minimum:__ -1\n- __Maximum:__ 1\n\n\nA single tuning run typically produces multiple timing results for each candidate parameter set, either as a result of\nperforming multiple trials, or tuning multiple models, or both. This parameter controls how these results are aggregated\ninto a single measure. The default setting (-1) chooses the aggregation automatically; setting 0 computes the average of\nall individual results; setting 1 takes the maximum.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/tunemetric.html).\n"] TuneMetric , # [doc = "- __Type:__ integer (`i32`)\n- __Default:__ 0\n- __Minimum:__ 0\n- __Maximum:__ MAXINT\n\n\nWhen using a WLS license, this parameter can be used to adjust the lifespan (in minutes) of a token. A token enables\nGurobi to run on that client for the life of the token. Gurobi will automatically request a new token if the current one\nexpires, but it won't notify the WLS server if it completes its work before the current token expires. A shorter\nlifespan is better for short-lived usage. A longer lifespan is better for environments where the network connection to\nthe WLS server is unreliable.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/wlstokenduration.html).\n"] WLSTokenDuration } # [derive (Debug , Copy , Clone , Eq , PartialEq , Hash , FromCStr , AsCStr)] pub enum StrParam { # [doc = "- __Type:__ string (`String`)\n- __Default:__ \".\"\n\n\nDetermines the directory into which nodes are written when node memory usage exceeds the specified `NodefileStart`\nvalue.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/nodefiledir.html).\n"] NodefileDir , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nDuring the MIP solution process, multiple incumbent solutions are typically found on the path to finding a proven\noptimal solution. Setting this parameter to a non-empty string causes these solutions to be written to files (in .sol\nformat) as they are found. The MIP solver will append _n.sol to the value of the parameter to form the name of the file\nthat contains solution number $n$. For example, setting the parameter to value solutions/mymodel will create files\nmymodel_0.sol, mymodel_1.sol, etc., in directory solutions.\n\nNote that intermediate solutions can be retrieved as they are generated through a callback (by requesting the MIPSOL_SOL\nin a MIPSOL callback). This parameter makes the process simpler.\n\nNote: Only affects mixed integer programming (MIP) models\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/solfiles.html).\n"] SolFiles , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nWhen using a distributed algorithm (distributed MIP, distributed concurrent, or distributed tuning), this parameter\nallows you to specify a Remote Services cluster that will provide distributed workers. You should also specify the\naccess password for that cluster, if there is one, in the `WorkerPassword` parameter. Note that you don't need to set\neither of these parameters if your job is running on a Compute Server node and you want to use the same cluster for the\ndistributed workers.\n\nYou can provide a comma-separated list of machines for added robustness. If the first node in the list is unavailable,\nthe client will attempt to contact the second node, etc.\n\nTo give an example, if you have a Remote Services cluster that uses port 61000 on a pair of machines named server1 and\nserver2, you could set `WorkerPool` to \"server1:61000\" or \"server1:61000,server2:61000\".\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/workerpool.html).\n"] WorkerPool , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nWhen using a distributed algorithm (distributed MIP, distributed concurrent, or distributed tuning), this parameter\nallows you to specify the password for the distributed worker cluster provided in the `WorkerPool` parameter.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/workerpassword.html).\n"] WorkerPassword , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nSet this parameter to the name of a node in the Remote Services cluster where you'd like your Compute Server job to run.\nYou can refer to the server using its name or its IP address. If you are using a non-default port, the server name\nshould be followed by the port number (e.g., server1:61000).\n\nYou will also need to set the `ServerPassword` parameter to supply the client password for the specified cluster.\n\nYou can provide a comma-separated list of nodes to increase robustness. If the first node in the list doesn't respond,\nthe second will be tried, etc.\n\nRefer to the Gurobi Remote Services Reference Manual for more information on starting Compute Server jobs.\n\nYou must set this parameter through either a gurobi.lic file (using COMPUTESERVER=server) or an empty environment.\nChanging the parameter after your environment has been created will have no effect.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/computeserver.html).\n"] ComputeServer , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nWhen using a token license, set this parameter to the name of the token server. You can refer to the server using its\nname or its IP address.\n\nYou can provide a comma-separated list of token servers to increase robustness. If the first server in the list doesn't\nrespond, the second will be tried, etc.\n\nYou must set this parameter through either a gurobi.lic file (using TOKENSERVER=server) or an empty environment.\nChanging the parameter after your environment has been created will have no effect.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/tokenserver.html).\n"] TokenServer , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nThe password for connecting to the server (either a Compute Server or a token server).\n\nFor connecting to the Remote Services cluster referred to by the `ComputeServer` parameter, you'll need to supply the\nclient password. Refer to the Gurobi Remote Services Reference Manual for more information on starting Compute Server\njobs.\n\nSupply the token server password (if needed) when connecting to the server referred to by the `TokenServer` parameter,\n\nYou must set this parameter through either a gurobi.lic file (using PASSWORD=pwd) or an empty environment. Changing the\nparameter after your environment has been created will have no effect.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/serverpassword.html).\n"] ServerPassword , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nThe router node for a Remote Services cluster. A router can be used to improve the robustness of a Compute Server\ndeployment. You can refer to the router using either its name or its IP address. A typical Remote Services deployment\nwon't use a router, so you typically won't need to set this parameter.\n\nRefer to the Gurobi Remote Services Reference Manual for more information on starting Compute Server jobs.\n\nYou must set this parameter through either a gurobi.lic file (using ROUTER=name) or an empty environment. Changing the\nparameter after your environment has been created will have no effect.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/csrouter.html).\n"] CSRouter , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nSpecifies one or more groups of cluster nodes to control the placement of the job. The list is a comma-separated string\nof group names, with optionally a priority for a group. For example, specifying group1:10,group2:50 means that the job\nwill run on machines of group1 or group2, and if the job is queued, it will have priority 10 on group1 and 50 on group2.\nNote that if the group is not specified, the job may run on any node. If there are no nodes in the cluster having the\nspecified groups, the job will be rejected.\n\nRefer to the Gurobi Remote Services Reference Manual for more information on starting Compute Server jobs and in\nparticular to Gurobi Remote Services cluster Grouping for more information on grouping cluster nodes.\n\nYou must set this parameter through either a license file (using GROUP=name) or an empty environment. Changing the\nparameter after your environment has been created will have no effect.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/csgroup.html).\n"] CSGroup , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nSet this parameter to the Access ID for your Instant Cloud license when launching a new instance. You can retrieve this\nstring from your account on the Gurobi Instant Cloud Manager website.\n\nYou must set this parameter through either a gurobi.lic file (using CLOUDACCESSID=id) or an empty environment. Changing\nthe parameter after your environment has been created will have no effect.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/cloudaccessid.html).\n"] CloudAccessID , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nSet this parameter to the Secret Key for your Instant Cloud license when launching a new instance. You can retrieve this\nstring from your account on the Gurobi Instant Cloud Manager website.\n\nYou must set this parameter through either a gurobi.lic file (using CLOUDSECRETKEY=key) or an empty environment.\nChanging the parameter after your environment has been created will have no effect.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/cloudsecretkey.html).\n"] CloudSecretKey , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nSet this parameter to the name of the cloud pool you would like to use for your new Instant Cloud instance. You can\nbrowse your existing cloud pools or create new ones from your account on the Gurobi Instant Cloud Manager website.\n\nYou must set this parameter through either a gurobi.lic file (using CLOUDPOOL=pool) or an empty environment. Changing\nthe parameter after your environment has been created will have no effect.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/cloudpool.html).\n"] CloudPool , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nSet this parameter to the host name of the Gurobi Cloud entry point. Currently cloud.gurobi.com.\n\nYou must set this parameter through either a gurobi.lic file (using CLOUDHOST=host) or an empty environment. Changing\nthe parameter after your environment has been started will result in an error.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/cloudhost.html).\n"] CloudHost , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nURL of the Cluster Manager for the Remote Services cluster.\n\nYou must set this parameter through either a gurobi.lic file (using CSMANAGER=YOUR_MANAGER_URL) or an empty environment.\nChanging the parameter after your environment has been started will result in an error.\n\nNote: Cluster Manager only\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/csmanager.html).\n"] CSManager , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nWhen a client authenticates with a Cluster Manager using a username and password, a signed token is returned by the\nserver to be used in further calls or command-line operations. It is used internally.\n\nNote: Cluster Manager only\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/csauthtoken.html).\n"] CSAuthToken , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nA unique identifier used to authenticate an application on a Gurobi Cluster Manager.\n\nYou can provide either an access ID and a secret key, or a username and password, to authenticate your connection to a\nCluster Manager.\n\nYou must set this parameter through either a gurobi.lic file (using CSAPIACCESSID=YOUR_API_ID) or an empty environment.\nChanging the parameter after your environment has been started will result in an error.\n\nNote: Cluster Manager only\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/csapiaccessid.html).\n"] CSAPIAccessID , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nThe secret password associated with an API access ID.\n\nYou can provide either an access ID and a secret key, or a username and password, to authenticate your connection to a\nCluster Manager.\n\nYou must set this parameter through either a gurobi.lic file (using CSAPISECRET=YOUR_API_SECRET_KEY) or an empty\nenvironment. Changing the parameter after your environment has been started will result in an error.\n\nNote: Cluster Manager only\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/csapisecret.html).\n"] CSAPISecret , # [doc = "__TODO__ : documentation\n"] Username , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nThe application name which will be sent to the server to track which application is submitting the batches or jobs.\n\nNote: Cluster Manager only\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/csappname.html).\n"] CSAppName , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nDetermines the name of the Gurobi log file. Modifying this parameter closes the current log file and opens the specified\nfile. Use an empty string for no log file. Use `OutputFlag` to shut off all logging.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/logfile.html).\n"] LogFile , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nSpecifies the name of the result file to be written upon completion of optimization. The type of the result file is\ndetermined by the file suffix. The most commonly used suffixes are .sol (to capture the solution vector), .bas (to\ncapture the simplex basis), and .mst (to capture the solution vector on the integer variables). You can also write a\n.ilp file (to capture the IIS for an infeasible model), or a .mps, .rew, .lp, or .rlp file (to capture the original\nmodel), or a .dua or .dlp file (to capture the dual of a pure LP model). The file suffix may optionally be followed by\n.gz, .bz2, or .7z, which produces a compressed result.\n\nMore information on the file formats can be found in the File Format section.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/resultfile.html).\n"] ResultFile , # [doc = "__TODO__ : documentation\n"] Dummy , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nIf you are running on a Compute Server, this parameter provides the Compute Server Job ID for the current job. Note that\nthis is a read-only parameter.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/jobid.html).\n"] JobID , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nIdentify the user connecting to the Remote Services Manager.\n\nYou can provide either a username and password, or an access ID and a secret key, to authenticate your connection to a\nCluster Manager.\n\nYou can set this parameter through either a gurobi.lic file (using USERNAME=YOUR_USERNAME) or an empty environment.\nChanging the parameter after your environment has been started will result in an error.\n\nNote: Cluster Manager only\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/username.html).\n"] UserName , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nWhen using a WLS license, set this parameter to the access ID for your license. You can retrieve this string from your\naccount on the Gurobi Web License Manager site.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/wlsaccessid.html).\n"] WLSAccessID , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nWhen using a WLS license, set this parameter to the secret key for your license. You can retrieve this string from your\naccount on the Gurobi Web License Manager site.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/wlssecret.html).\n"] WLSSecret , # [doc = "- __Type:__ string (`String`)\n- __Default:__ \"\"\n\n\nIf you are using a WLS license and have retrieved your own token through the WLS REST API, use this parameter to pass\nthat token to the library. If you do this, you don't need to set any other WLS-related parameters.\n\n[Reference manual](https://www.gurobi.com/documentation/9.5/refman/wlstoken.html).\n"] WLSToken } pub (super) mod enum_exports { pub use super :: DoubleParam ; pub use super :: IntParam ; pub use super :: StrParam ; } pub mod variant_exports { # [doc (inline)] pub use super :: DoubleParam :: * ; # [doc (inline)] pub use super :: IntParam :: * ; # [doc (inline)] pub use super :: StrParam :: * ; }